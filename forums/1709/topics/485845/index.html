<!DOCTYPE html>
<html lang='en'>
  <head>
    <script>(function(w,d,s,l,i){w[l]=w[l]||[];w[l].push({'gtm.start':new Date().getTime(),event:'gtm.js'});var f=d.getElementsByTagName(s)[0],j=d.createElement(s),dl=l!='dataLayer'?'&l='+l:'';j.async=true;j.src='https://www.googletagmanager.com/gtm.js?id='+i+dl;f.parentNode.insertBefore(j,f);})(window,document,'script','dataLayer','GTM-PK63DK');</script>
    <meta content='text/html; charset=UTF-8' http-equiv='Content-Type'>
    <meta charset='utf-8'>
    <meta content='width=device-width, initial-scale=1, shrink-to-fit=no' name='viewport'>
    <link crossorigin='anonymous' href='https://stackpath.bootstrapcdn.com/bootstrap/4.1.1/css/bootstrap.min.css' integrity='sha384-WskhaSGFgHYWDcbwN70/dfYBj47jz9qbsMId/iRN3ewGhXQFZCSftd1LZCfmhktB' rel='stylesheet'>
    <link href='/styles.css' rel='stylesheet'>
    <title>Java &amp; Bluetooth</title>
    <script async='async' src='https://www.googletagservices.com/tag/js/gpt.js'></script><script>var googletag=googletag ||{}; googletag.cmd=googletag.cmd || [];</script><script>googletag.cmd.push(function(){googletag.defineSlot('\/1010898\/sgforums_interstitial', [ 1.0 , 1.0], 'div-gpt-ad-1528181032761-0').setTargeting('forum', ['1709']).setTargeting('topic', ['485845']).addService(googletag.pubads()); googletag.defineSlot('\/1010898\/sgforums_leaderboard', [[ 728.0 , 90.0], [ 970.0 , 250.0]], 'div-gpt-ad-1528181032761-1').setTargeting('forum', ['1709']).setTargeting('topic', ['485845']).addService(googletag.pubads()); googletag.defineSlot('\/1010898\/sgforums_mpu', [ 300.0 , 250.0], 'div-gpt-ad-1528181032761-2').setTargeting('forum', ['1709']).setTargeting('topic', ['485845']).addService(googletag.pubads()); googletag.defineSlot('\/1010898\/sgforums_supersky', [ 160.0 , 600.0], 'div-gpt-ad-1528181032761-3').setTargeting('forum', ['1709']).setTargeting('topic', ['485845']).addService(googletag.pubads()); googletag.pubads().enableSingleRequest(); googletag.enableServices();});</script>
  </head>
  <body>
    <noscript><iframe src="https://www.googletagmanager.com/ns.html?id=GTM-PK63DK"height="0" width="0" style="display:none;visibility:hidden"></iframe></noscript>
    <div class='container'>
      <a href='/'>Home</a>
      >
      <a href='/forums/1709/'>Computer Workshop</a>
      <h1>Java &amp; Bluetooth</h1>
      <nav class='pagination'>
      </nav>
      <ul class='list-group posts'>
        <li class='list-group-item post'>
          <div class='row'>
            <div class='col-md-2 meta'>
              <div class='author'>The Code</div>
              <time class='date' datetime='2014-07-24T15:50:58+00:00'>24 Jul 14, 15:50</time>
            </div>
            <div class='col-md body'>
              <p> </p>
              <p><span style="line-height: 115%; font-size: 48pt;"><span style="font-family: Calibri;">Java &amp; Bluetooth</span></span></p>
              <p> </p>
              <p><span style="line-height: 115%; font-size: 20pt;"><span style="font-family: Calibri;">Developing</span></span><br><span style="line-height: 115%; font-size: 20pt;"><span style="font-family: Calibri;">applications for</span></span><br><span style="line-height: 115%; font-size: 20pt;"><span style="font-family: Calibri;">mobile devices</span></span></p>
              <p> </p>
              <p><span style="line-height: 115%; font-size: 16pt;"><span style="font-family: Calibri;">PAUL TREMBLETT</span></span></p>
              <p> </p>
              <p><span style="line-height: 115%; font-size: 54pt;"><span style="font-family: Calibri;"><span style="line-height: 115%; color: #4a206a; font-size: 54pt;">T</span></span></span>he Java specification Request 82 (<a href="http://jcp.org/">http://jcp.org/</a>) define a standard API for developing Bluetooth applications using Lhe Java programming language. In this article, I examine how you can use the JSR 82 API to determine properties of local Bluetooth devices; discover nearby Bluetooth devices and determine the services they offer; and connect to devices and communicate with them using well-defined protocols. Typically, Bluetooth applications run under Java 2 Micro Edition Q2ME), but one of the requirements defined by the specification is that it should be able to run on any Java 2 platform that supplies the Generic Connection Framework (GCF). Consequently, I was able to run all of the sample code presented here under Java 2 Standard (J2SE) using Rococosoft's Impronto Developer Kit (<a href="http://www.rococosoft.com">http://www.rococosoft.com</a>), which implements GCF.</p>
              <p> </p>
              <p><span style="line-height: 115%; font-size: 16pt;"><span style="font-family: Calibri;">Device Properties</span></span></p>
              <p> </p>
              <p>All Bluetooth devices do not have identical characteristics. The JSR 82 API defines properties that either provide additional information about a Bluetooth system or define restrictions that are placed on an application by an implementation. Each property can be retrieved by a call to the static getProperty() method of the LocalDevice class. The single argument expected by the method is a String that contains the name of the property. The method returns a String that contains the value of the specified property. DisplayDeviceProperties.java (Listing One) displays the results returned when each of the properties defined by the API is retrieved. When running the program on a Linux machine using a Belkin USB Bluetooth device, the BlueZ stack, and Rococosoft's Impronto, the output looks like this:</p>
              <p>bluetooth.api.version                          1.0a            <br>bluetooth.12cap.receiveMTU.max      65535<br>bluetooth.connected.devices.max      7<br>bluetooth.connected.inquiry              true<br>bluetooth.connected.page                 true<br>bluetooth.connected.inquiry.scan      true<br>bluetooth.connected.page.scan        true<br>bluetooth.master.switch                      true<br>bluetooth.sd.trans.max                       1<br>bluetooth.sd.attr.retrievable.max       128</p>
              <p>   If you run the example, you can show how the values that are returned reflect the current Bluetooth configuration. Just modify the inquiry and page scan values in /etc/bluetooth/hcid.conf, bring the Bluetooth device down and back up, rerun the program, and observe the results.</p>
              <p> </p>
              <p><span style="line-height: 115%; font-size: 16pt;"><span style="font-family: Calibri;">Discovery</span></span></p>
              <p> </p>
              <p>An important characteristic of Bluetooth devices is the ability to find other Bluetooth devices to which they can connect, and once such devices are found, to determine the services they offer. The process by which this is accomplished is called "Discovery." The API provides classes that enable discovery. You start the discovery process by invoking the static getLocal Device() method of the LocalDevice class. The LocalDevice object this method returns, which is constant across multiple invocations, provides the lowest level of interface possible into the Bluetooth stack and provides access to, and control of, the local Bluetooth device.</p>
              <p>   The local device must have exactly one DiscoveryAgent object, which you retrieve by calling the getDiscoveryAgent() method on the LocalDevice object. The DiscoveryAgent class provides methods to perform both device and service discovery.</p>
              <p>   The DiscoveryAgent object provides two ways to discover devices. The first is the nonblocking startInquiry() method, which finds devices in proximity to the local device and returns each discovered device using a callback to the deviceDiscovered() method of the DiscoveryListener interface. You provide implementations of each of the methods the interface defines. When the inquiry is complete, the inquiryCompleted() method is called. The DiscoveryAgent class also provides a method for canceling an inquiry. An example of when you might invoke the cancel() method is if you are searching for any Bluetooth printer and are willing to accept the first one that is returned.</p>
              <p>   The second device discovery method is the blocking retrieveDevices() method, which returns a list of devices that have been discovered by previous inquiries and are classified as "preknown."</p>
              <p>   The DiscoveryAgent object provides two methods you can use to discover services. The first is selectService(), which attempts to locate a service that contains a specified universally unique identifier (UUID) in the ServiceClassIDList of its service record. If it finds the service, it returns a string that can be used to establish a connection to the service.</p>
              <p>   The second method, searchServices(), starts a search for devices that have all the UUIDs in a specified set. As services are found, they are reported via a callback to the servicesDiscovered() method of the DiscoveryListener interface, which passes an array of ServiceRecord objects. The ServiceRecord interface contains methods you can use to obtain information about a service. When a service search is completed or terminated because of an error, the serviceSearchCompleted() is called.</p>
              <p>   DiscoveryDemo.java (available electronically; <a href="http://www.ddj.com">http://www.ddj.com</a>) shows how to discover all nearby Bluetooth devices and the services they offer. It implements the DiscoveryListener interface. When I run the program using the configuration previously described and turn on my Belkin F8T030 Bluetooth Access Point and my PalmOne Zire 72, I see the results in DiscoveryDemo.out (Listing Two). I used ca.tremblett.bluetooth. BluetoothUtils (available electronically) to convert the numeric device codes to English descriptions and to help format the service records.</p>
              <p> </p>
              <p><span style="line-height: 115%; font-size: 16pt;"><span style="font-family: Calibri;">Communicating</span></span><br><span style="line-height: 115%; font-size: 16pt;"><span style="font-family: Calibri;">With Devices</span></span></p>
              <p> </p>
              <p>The API defined by JSR 82 was designed to operate on top of the Connected Limited Device Configuration (CLDC), an optional package designed to extend the capability of a J2ME profile (such as the MIDP Mobile Information Device Profile). Chapter 2 of the JSR 82 specification states that the API should only require CLDC libraries. It further states that it should be able to run on any Java 2 platform that supports the Generic Connection Framework (GCF). The GCF is already implemented in Connected Device Configuration (CDC)-based profiles, such as the Foundation Profile, the Personal Basis Profile, and the Personal Profile. When JSR 197 (Generic Connection Framework Optional Package for J2SE) is complete, GCF will be available as the optional package javax.microedition. Until then, you can use toolkits that implement the GCF. Again, I use Rococosoft's Impronto.</p>
              <p>   When you use the GCF, you connect to a remote device or service by calling one of the three Connector.open() methods. All three take a String containing a URL as the first argument. Look again at DiscoveryDemo.out (Listing Two) and you see the URL extracted from each service record. Having the ability to extract this URL means that once you discover the service you need, you know how to access it. The URL is the only argument accepted by the first form of Connector.open(). The second form accepts an argument that specifies a mode, which can be READ, WRITE, or READ_WRITE. In addition to the mode argument, the third form takes an additional argument that indicates whether the caller wants timeout exceptions.</p>
              <p>   Once a connection has been established between two Bluetooth devices, communication can take place. The classes and methods you use to perform the transfer of data between the devices depend on the protocol you are using.</p>
              <p> </p>
              <p><span style="line-height: 115%; font-size: 16pt;"><span style="font-family: Calibri;">The Logical Link Control and</span></span> <br><span style="line-height: 115%; font-size: 16pt;"><span style="font-family: Calibri;">Adaption Profile</span></span></p>
              <p> </p>
              <p>The L2CAP protocol lies closest to the stack. The server side of an L2CAP connection uses an L2CAPConnectionNotifier object, which it obtains by passing a suitable URL to Connector.open() and casting the Connection object that is returned. The protocol used to form the URL is btl2cap. The target contains "localhost" and a Universally Unique Identifier (UUID) for the service. The parameters can include keyword/value pairs for the service name, ReceiveMTU and TransmitMTU and boolean values for master, encrypt, and authorize and authenticate. Once the server program gets the L2CAPConnectionNotifier object, it obtains an L2CAPConnection object by calling the notifier's acceptAndOpen() method, which blocks until a connection is received from a client. The server typically passes the connection it receives from the acceptAndOpen() method to a thread that conducts the conversation with the client and then closes the connection. While the thread is executing, the server makes another call to acceptAndOpen(). L2CAPServer.java (available electronically) is a simple server that accepts and displays a message received from a client.</p>
              <p>   When an L2CAP server uses an L2CAP-Connection's receive() method to receive a packet, if the size of the buffer passed to the method is smaller than ReceiveMTU, all data that will not fit into the buffer is discarded. The server must be aware of this to avoid losing data. In the example, I chose a value of 64 for ReceiveMTU. This is much smaller than you would normally use, but it demonstrates how the server should receive data in chunks and how the client should be aware of the server's limitations.</p>
              <p>   The L2CAP client obtains the L2CAP-Connection object it needs to communicate with the server by passing a URL to Connector.open() and casting the Connection that is returned. The protocol used to form the URL is btl2cap. The target is comprised of the Bluetooth address of the server and the port. The parameters  can include keyword/value pairs for ReceiveMTU and TransmitMTU and boolean values for master, encrypt, and authorize and authenticate. Packets of data are exchanged with the server using the send() and receive() methods. The client is responsible for making sure it does not send a packet larger than the server is capable of receiving, so it determines that value by invoking the L2CAPConnection object's getTransmitMTU() method and sends the message as a series of packets of the appropriate size. L2CAPClient.java (available electronically) is a client that can communicate with L2CAPServer.java. When you run the client, the server displays the output in L2CAPServer.out (Listing Three). Notice how the message is received as three packets of 64 bytes each followed by a packet whose length is 7 bytes.</p>
              <p> </p>
              <p><span style="line-height: 115%; font-size: 16pt;"><span style="font-family: Calibri;">The Serial Port Profile</span></span></p>
              <p> </p>
              <p>The Serial Port Profile (SPP), based on the Bluetooth Radio Frequency Communications Protocol (RFCOMM), provides RS-232 serial port emulation for Bluetooth links. An SPP server passes an appropriate URL to Connector.open() and casts the resulting object to the StreamConnectionNotifier interface. The protocol used to build the URL string is btspp. The target contains "localhost" and a UUID that identifies the service. The parameters can include boolean values for master, encrypt, and authorize and authenticate. The implementation of Connector.open() creates a service record and adds it to the Service Discovery Database (SDDB). It also assigns a channel, which it adds to the ProtocolDescriptorList in the service record along with the UUID. The server invokes the acceptAndOpen() method on the StreamConnectionNotifier object; this method returns a StreamConnection.Data is transmitted using the input and output streams that are returned by the getlnputStream() and getOutputStream() methods of the Stream-Connection. SerialPortServer.java (available electronically) is a simple server that returns the current date/time to a client.</p>
              <p>   An SPP client makes a connection to the server by passing an appropriate URL to Connector.open() and casting the resulting object to StreamConnection. You can obtain the URL by passing the UUID that describes the service to the DiscoveryAgent object's selectService() method. If you print the URL, you see that the protocol is btspp. The data transmission mechanism is identical to that used by the server. SerialPortClient.java is a client that requests the time from SerialPortServer.java. When you run the program, you see this output:</p>
              <p>locating service for UUID:<br>3F9FA89220578C313344AAB294118F01<br>URL = btspp://000A3A52BC04:1;<br>                 authenticate=false;encrypt=false;<br>                                                  master=false<br>25 bytes received<br>received date/time 06 February 2005 15:59:12</p>
              <p> </p>
              <p><span style="line-height: 115%; font-size: 16pt;"><span style="font-family: Calibri;">The Object</span></span><br><span style="line-height: 115%; font-size: 16pt;"><span style="font-family: Calibri;">Exchange Protocol</span></span></p>
              <p> </p>
              <p>The Object Exchange Protocol (OBEX) was designed by the Infrared Association (IrDA) for "pushing" or "pulling" objects such as files, vCards, or even byte arrays to/from clients and servers. As with the other Protocols OBEX clients and servers communicate over a connection that is obtained by passing the appropriate URL to the Connector.open() method. The protocol used to build the URL is formed by the concatenation of the name of the underlying protocol and "obex." So, for TCP/ IP and IrDA's Tiny TP, you would use tcpobex and irdaobex, respectively. RFCOMM deviates from the pattern and uses btgoep, indicating that the protocol is the implementation of the Generic Object Exchange Protocol (GOEP) defined by the Bluetooth Special Interest Group (SIG). I limit this discussion to RFCOMM.</p>
              <p>   OBEXDemo.java (available electronically) is an OBEX client that executes on a PC and pushes a vCard that it reads from the file Marcella_Adamsson.vcf (available electronically) to a PDA. The target component of the URL the client uses is the Bluetooth address of the remote device on which the server is running, plus the channel separated by a colon. Allowable parameters are boolean values for master, encrypt, and authenticate.</p>
              <p>   Once the client establishes a connection to the client, it conducts an OBEX session that is similar in many ways to an HTTP session. The client starts the session by sending a CONNECT command and ends it by sending a DISCONNECT command. In between, the client can use PUT/GET commands to send a receive object or specify a target location using the SETPATH command. The client and server can exchange additional information using headers similar to those used by HTTP.</p>
              <p>   When I run the client on my laptop specifying the Bluetooth address of my PalmOne Zire 72 as a target, the PDA displays the dialog box in Figure 1. When I accept the vCard on the PDA by tapping "OK," the contents of the card in Figure 2 are displayed.</p>
              <p> </p>
              <p><span style="line-height: 115%; font-size: 16pt;"><span style="font-family: Calibri;">Conclusion</span></span></p>
              <p> </p>
              <p>The classes and interfaces supplied with an implementation of JSR 82 provide everything you need to develop Bluetooth applications for a variety of devices. The approach taken by the designers of the JSR shields you from unnecessary lower level details and Java guarantees pottability.</p>
              <p> </p>
              <p>Bluetooth</p>
              <p>? Do you want to accept "Marcella-Adamsson.vcf" into Contacts?</p>
              <p>Category: â–¼ Unfiled</p>
              <p>Yes No</p>
              <p>Figure 1: PDA dialog box when running the client on a laptop.</p>
              <p><br>Contact                    Unfiled</p>
              <p>Marcella Adamsson<br>World-class aunt</p>
              <p>E-mail: <a href="mailto:m.adamsson@somewhere.com">m.adamsson@somewhere.com</a></p>
              <p>Done Edit New</p>
              <p>Figure 2: Accepting a vCard on a PDA.</p>
              <p><br><strong>Listing One</strong></p>
              <p>package ea. tremblett. bluetooth;<br>import javax. blue tooth .Local Device:</p>
              <p>/** @author paul tremblett <br> * A simple program that displays Bluetooth properties.<br>*/</p>
              <p>public class DisplayBluetoothProperties {</p>
              <p>/* Array of String containing the properties defined by JSR 82. */</p>
              <p>private static final String[] properties = {<br>"bluetooth.api. version",<br>"bluetooth.12cap.receiveMTU.max",<br>"bluetooth.connected.devices.max",<br>"bluetooth.connected.inquiry".<br>"bluetooth.connected.page",<br>"bluetooth.connected.inquiry.scan",<br>"bluetooth.connected.page.scan",<br>"bluetooth.master.switch",<br>"bluetooth.sd.trans.max",<br>"bluetooth.sd.attr.retrievable.max"<br>};<br>/* The main method. <br> * @param args Command line arguments. None are required and none accepted .<br> */<br>public static void main(String[] args) {<br>for (int i = Ø: i &lt; properties.length; ++i) {<br>  System.out.printIn(properties[i] + " = " +<br>    LocalDevice.getProperty(properties[i]));</p>
              <p>   }<br>  }<br> }</p>
              <p><strong>Listing Two</strong></p>
              <p>finding devices<br>2 devices found<br>Device # 1:<br>Address: ØØØ272ØØDBF9<br>BELKIN_ØØdbf9 [192.168.2.2Ø2]<br>class = (Major:Lan/Network Access Point] [utilization:Fully available]<br>Service record # 1:<br>&lt;DATSEQ&gt;<br>  &lt;DATSEQ&gt;<br>&lt;UUID&gt;ØØØØØ1ØØØØØØ1ØØØ8ØØØØØ8Ø5F9B34FB&lt;/UUID&gt;<br>  &lt;/DATSEQ&gt;<br> &lt;DATSEQ&gt;<br>&lt;UUID&gt;ØØØØØØØ3ØØØØ1ØØØ8ØØØØØ8Ø5F9B34FB&lt;IUUID&gt;<br>&lt;U_INT_1&gt;3&lt;/U_INT_1&gt;<br>   &lt;/DATSEQ&gt;<br>  &lt;/DATSEQ&gt;<br>&lt;DATSEQ&gt;<br>&lt;UUID&gt;ØØØØ11Ø1ØØØØ1ØØØ8ØØØØØ8Ø5F9B34FB&lt;/UUID&gt;<br>&lt;/DATSEQ&gt;<br>&lt;U_INT_4&gt;65537&lt;/U_INT_4&gt;<br>URL: [btspp: //ØØØ272ØØDBF9:3;authenticate=false; encrypt=false;<br>master=false]<br>Service record # 2:<br>&lt;DATSEQ&gt;<br>&lt;DATSBQ&gt;<br>&lt;UUID&gt;ØØØØØ1ØØØØØØ1ØØØ8ØØØØØ8Ø5F9B34FB&lt;/UUID&gt;<br>&lt;/DATSEQ&gt;<br>&lt;DATSEQ&gt;<br>&lt;UUID&gt;ØØØØØØØ3ØØØØ1ØØØ8ØØØØØ8Ø5F9B34FB&lt;/UUID&gt;<br>&lt;U_INT_1&gt;1&lt;/U_INT_1&gt;<br>   &lt;/DATSEQ&gt;<br>  &lt;/DATSEQ&gt;<br>&lt;DATSEQ&gt;<br>&lt;UUID&gt;ØØØØ11Ø2ØØØØ1ØØØ8ØØØØØ8Ø5F9B34FB&lt;IUUID&gt;<br>&lt;/DATSEQ&gt;<br>&lt;U_INT_4&gt;65536&lt;/U_INT_4&gt;<br>URL: [btspp://ØØØ272ØØDBF9:1; authenticate=false; encrypt=false;<br>master=false)<br>Device # 2:<br>Address: ØØØ7EØ43E7A5<br>Paul's Zire 72<br>class = (Major:Computer] [Minor:Palm sized PC/PDA]<br>Service record # 1:<br>&lt;DATSEQ&gt;<br>  &lt;DATSEQ&gt;<br>&lt;UUID&gt;ØØØØØ1ØØØØØØ1ØØØBØØØØØBØ5F9B34FB&lt;/UUID&gt;<br>&lt;/DATSEQ&gt;<br>&lt;DATSEQ&gt;<br>&lt;UUID&gt;ØØØØØØØ3ØØØØ1ØØØ8ØØØØØ8Ø5F9B34FB&lt;/UUID&gt;<br>&lt;U_INT_1&gt;1&lt;/U_INT_1&gt;<br>&lt;/DATSEQ&gt;<br>&lt;DATSEQ&gt;<br>&lt;UUID&gt;ØØØØØØØ8ØØØØ1ØØØ8ØØØØØ8Ø5F9B34FB&lt;/UUID&gt;<br>&lt;/DATSEQ&gt;<br>&lt;/DATSEQ&gt;<br>&lt;DATSEQ&gt;<br>&lt;UUID&gt;ØØØØ11Ø5ØØØØ1ØØØ8ØØØØØ8Ø5F9B34FB&lt;/UUID&gt;<br>&lt;/DATSEQ&gt;<br>&lt;U_INT_4&gt;65537&lt;/U_INT_4&gt;<br>URL: [btgoep://ØØØ7EØ43E7A5:1; authenticate=false; encrypt=false;<br>master=false]</p>
              <p><strong>Listing Three</strong></p>
              <p>accepting connections<br>waiting for client connection<br>got client connection<br>waiting for client connection<br>ClientThread running<br>received 64 bytes<br>received 64 bytes<br>received 64 bytes<br>received 7 bytes<br>done<br>'The time has come,' the Walrus said,<br>'To talk of many things:<br>Of shoes -- and ships -- and sealing wax --<br>Of cabbages -- and kings --<br>And why the sea is boiling hot --<br>And whether pigs have wings.'</p>
              <p> </p>
              <p>Paul is a technical lead at Vonage. He can be reached at <a href="mailto:paul@tremblett.us">paul@tremblett.us</a>.</p>
              <p> </p>
              <p>Dr Dobb's Journal, #374 July 2005, Pg 41-44</p>
            </div>
          </div>
        </li>
        <li class='list-group-item'>
          <div id='div-gpt-ad-1528181032761-2' style='height:250px; width:300px;'><script>googletag.cmd.push(function(){googletag.display('div-gpt-ad-1528181032761-2');});</script></div>
        </li>
      </ul>
      <nav class='pagination'>
      </nav>
      <footer>
        <nav class='nav'>
          <a class='nav-link' href='/'>Home</a>
          <a class='nav-link' href='/privacy/'>Privacy</a>
          <a class='nav-link' href='/terms/'>Terms</a>
        </nav>
      </footer>
    </div>
    <div id='div-gpt-ad-1528181032761-0' style='height:1px; width:1px;'><script>googletag.cmd.push(function(){googletag.display('div-gpt-ad-1528181032761-0');});</script></div>
  </body>
</html>
